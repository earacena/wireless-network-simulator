Channel Allocation:

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Parsing the GUI text file */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

Take the textfile generated by the gui side with all the randomly generated coordinates
Construct objects 
once the objects are constructed, back end will handle everything else

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Basestation Class */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	char name: basestation name, using letters
	int radius: a fixed radius we hardcode for the basestations range
	vector nodes: vector of all nodes in the domain of the basestation
	vector adjacent: a list of all basestations that overlap with this basestation


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Node Class */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	
	int name: node name, using numbers
	char basestation: name of basestation the node is associated with
	int radius: range of the node
	2D vector channels: vector of the number of channels, for each adjacent node;
					 using a vector to keep the number of channels dynamic 
					 for the experiments part of the project
					 channels can be implemented as either a struct or maybe tuples:
					 	Channel:
					 		bool taken: is the channel being used
					 		int weight: probability that a primary is using it
					 	(Are channels static for all nodes in a basestation?)
	vector route: vector that contains the route for transmission by the node
				  The route will contain tuples (node name, channel vector index)



/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Channel Allocation Algorithm */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	Overlap(basestation 1, basestation2): returns nodes that overlap 2 basestations
	
	Graph(basestation 1): generates an adjacency list of all the nodes that are in one basestation. 
		This portion will deal with channel selection. The graph edges will be an available channel 
		with the least probability of the primary interfering. The weights of each channel will be 
		assigned when initializing each node class via the exponential generator 
		(we can probably put this in the constructor assuming that the channel weights are not static). 
		The graph generation will be implemented as a table. and weights of edges will be selected by going through the channel vector. 
		Then we can apply the dijikistra's algorithm to this graph
	
	SameBasestation(node 1, node 2): returns a bool value, if the two nodes are in the same basestation.
		char node1, node2;
		1.get_basestation() = node1;
		2.get_basestation() = node2;
		if(node1==node2){
			return true;
		}
		return false;

	Input taken from the GUI:
		start node, destination node

	IF (SameBasestation(the nodes))
		Graph(node.get_basestation())
		apply dijikistra(graph,node1,node2)
		write the path to textfile for the GUI to read 
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
			What Saptarshi explained; new channel allocation algorithm
	General rules:
	"This is a real time system" = the nodes are listening and sending at the same time
		Implementations wise this means: 
			when routing 2 neightboring nodes cannot use the same channel, 
			because since the nodes are listening and sending by using the same channel an intermediary node
			would be interfereing with itself
		
			A ------> B ------> C  ILLEGAL!
			    1 	       1
			Node B would be interfering with itself, so when sending it will have to send via a new channel
			
			A ------> B ------> C ------> D GOOD! //you can switch back
			    1         2         1
		Furthermore, the channel weights are STATIC. so every node has the same set of channels and those channels 
		will have the same weight throughout.
		
	"The basestations really don't mean anything" = So the routing is just gonna be ad hoc, the basestations are just 
							for organization
		Implementations wise this means: 
			For every route, we generate 1 graph for the entire map. The route is node to node, so all that matters
			is if nodes are in range of each other, not the basestation ranges.
			
	"You can't listen to two ppl at the sametime" = if a node is already using a channel to revieve data, it can't recieve data
							even if its from a different channel
		Implementation wise this means:
			When we generate a new graph for another node transmission, we just generate the graph excluding the nodes 
			that are already being used for a route.
	
	So basically what we need to do is generate all possible paths for a given start and destination nodes.
	Apparently our previous strategy would work all the time.
	So if there are N channels and M nodes, we'd generate a new graph using all the different combinations of channels
	Now thats computationally fucking nuts, thats going to be N^(M) different graphs. 
	Brute Force:
	We generate all the different graphs
	Then we'd apply dijikistra to each of them and find a route
	store all the routes, then iterate through the stored routes, and exclude illegal routes (adjacent and co channel interference)
	Then pick the min of all the routes
	
	The maybe better method? 
	Dynamically adapt the graph while traversing it.
	This is so that we can just not produce EVERY route from every graph even the illegal ones.
	So try to generate all the legal paths then find the min of those paths. 
	If we employ adjacent channel interference it'll actually help because then it reduces the number of possible channels 
	to take. He said 2 channel adjacency is best. 
	//Idk yet I'll try to build on this more.
			
	
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Mobility Management */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	A simple way of doing it:
		Only the nodes not currently involved in a route is moving
		Update movement of nodes right after one of the routes are set

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Things to consider: */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

Co-channel interference:
	The bool assigned to each of the channels will indicate whether a channel is being used and thus the channel can be avoided, 
	hence no co-channel interference

Adjacent channel interference:
	This will actually help our project (look at the "new channel allocation algorithm" 
	The optimal adjacency is 2 channels
	
Hidden terminal:
	most of this will be taken care of while implementing the routing stuff
	
Exposed terminal:
	same

