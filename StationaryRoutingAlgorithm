Stationary Channel Allocation:

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Parsing the GUI text file */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

Take the textfile generated by the gui side with all the randomly generated coordinates
Construct objects 
once the objects are constructed, back end will handle everything else

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Basestation Class */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	char name: basestation name, using letters
	int radius: a fixed radius we hardcode for the basestations range
	vector nodes: vector of all nodes in the domain of the basestation
	vector adjacent: a list of all basestations that overlap with this basestation


/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Node Class */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
	
	int name: node name, using numbers
	char basestation: name of basestation the node is associated with
	int radius: range of the node
	2D vector channels: vector of the number of channels, for each adjacent node;
					 using a vector to keep the number of channels dynamic 
					 for the experiments part of the project
					 channels can be implemented as either a struct or maybe tuples:
					 	Channel:
					 		bool taken: is the channel being used
					 		int weight: probability that a primary is using it
					 	(Are channels static for all nodes in a basestation?)
	vector route: vector that contains the route for transmission by the node
				  The route will contain tuples (node name, channel vector index)



/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Channel Allocation Algorithm */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

	Overlap(basestation 1, basestation2): returns nodes that overlap 2 basestations
	
	Graph(basestation 1): generates an adjacency list of all the nodes that are in one basestation. 
		This portion will deal with channel selection. The graph edges will be an available channel 
		with the least probability of the primary interfering. The weights of each channel will be 
		assigned when initializing each node class via the exponential generator 
		(we can probably put this in the constructor assuming that the channel weights are not static). 
		The graph generation will be implemented as a table. and weights of edges will be selected by going through the channel vector. 
		Then we can apply the dijikistra's algorithm to this graph
	
	SameBasestation(node 1, node 2): returns a bool value, if the two nodes are in the same basestation.
		char node1, node2;
		1.get_basestation() = node1;
		2.get_basestation() = node2;
		if(node1==node2){
			return true;
		}
		return false;

	Input taken from the GUI:
		start node, destination node

	IF (SameBasestation(the nodes))
		Graph(node.get_basestation())
		apply dijikistra(graph,node1,node2)
		write the path to textfile for the GUI to read 

	ELSE {...} //we'll worry about this later, lets just get the first part working first

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
/* Things to consider: */
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/

Co-channel interference:
	The bool assigned to each of the channels will indicate whether a channel is being used and thus the channel can be avoided, 
	hence no co-channel interference

Adjacent channel interference:
	He said dwai. We could easily integrate this later for extra points pretty easily. We've got much bigger problems. 

Hidden terminal:
	Idk where this even happens for this product

Exposed terminal:
	same

